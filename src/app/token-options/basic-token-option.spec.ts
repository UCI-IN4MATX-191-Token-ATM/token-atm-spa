import { isLeft } from 'fp-ts/lib/Either';
import { Base64 } from 'js-base64';
import {
    BasicTokenOptionDataDef,
    type BasicTokenOptionData,
    type RawBasicTokenOptionData,
    BasicTokenOption
} from './basic-token-option';
import type { TokenOptionGroup } from 'app/data/token-option-group';
import { TO_BE_SUPER_SET_OF_MATCHER } from 'app/utils/test/to-be-super-set-of-matcher';
// +------------------------------------------------------------+
// | Import any other needed functions, such as unix time below |
// +------------------------------------------------------------+
// e.g., `import { fromUnixTime, getUnixTime } from 'date-fns';`

describe('BasicTokenOption', () => {
    const validValues: BasicTokenOptionData[] = [
        {
            type: '', // TODO: Fill with correct type name
            id: 1,
            name: 'A',
            description: '',
            tokenBalanceChange: 1,
            isMigrating: undefined
            // TODO: Add any other properties generated by this Token Option's Mixins
            //       e.g., startTime, endTime, surveyId, etc.
        }
    ];
    const validRawValuesPair: [BasicTokenOptionData, RawBasicTokenOptionData][] = validValues.map((v) => {
        const result: RawBasicTokenOptionData = {
            ...v,
            description: v.description ? Base64.encode(v.description) : undefined
            // TODO: Programmatically update any of the properties to the proper encoded form
            //       e.g., `startTime: getUnixTime(v.startTime)` or `quizId: v.surveyId`
        };
        // TODO: Remove any extraneous properties (those that are valid inputs, but not encodings)
        //       e.g., `delete (result as any)['surveyId'];`
        return [v, result];
    });
    const invalidValues = [
        {}
        // TODO: Add invalid JSON objects for this token option
    ];
    const invalidRawValues = [
        {}
        // TODO: Add invalid encoded form JSON objects for this token option
    ];

    describe('BasicTokenOptionDataDef', () => {
        validRawValuesPair.forEach(([expected, value]) => {
            it(`should decode sucessfully with valid raw value ${JSON.stringify(value)}`, () => {
                const result = BasicTokenOptionDataDef.decode(value);
                expect(isLeft(result)).toBeFalse();
                if (!isLeft(result)) expect(result.right).toEqual(expected);
            });
        });

        invalidRawValues.forEach((value) => {
            it(`should fail to decode with invalid raw value ${JSON.stringify(value)}`, () => {
                const result = BasicTokenOptionDataDef.decode(value);
                expect(isLeft(result)).toBeTrue();
            });
        });

        validValues.forEach((value) => {
            it(`should validate successfully with valid value ${JSON.stringify(value)}`, () => {
                expect(BasicTokenOptionDataDef.is(value)).toBeTrue();
            });
        });

        invalidValues.forEach((value) => {
            it(`should fail to validate with invalid value ${JSON.stringify(value)}`, () => {
                expect(BasicTokenOptionDataDef.is(value)).toBeFalse();
            });
        });

        validRawValuesPair.forEach(([value, expected]) => {
            it(`should encode successfully with valid value ${JSON.stringify(value)}`, () => {
                const result = BasicTokenOptionDataDef.encode(value);
                expect(result).toEqual({
                    ...expected,
                    description: expected.description ?? ''
                });
            });
        });
    });

    describe('BasicTokenOption', () => {
        let value: BasicTokenOption;

        beforeEach(() => {
            value = new BasicTokenOption();
            jasmine.addMatchers(TO_BE_SUPER_SET_OF_MATCHER);
        });

        it('should have property `type`', () => {
            expect(value.type).toEqual('');
            value.type = 'A';
            expect(value.type).toEqual('A');
        });

        it('should have property `id`', () => {
            expect(value.id).toEqual(-1);
            value.id = 1;
            expect(value.id).toEqual(1);
        });

        it('should have property `name`', () => {
            expect(value.name).toEqual('');
            value.name = 'Name';
            expect(value.name).toEqual('Name');
        });

        it('should have property `description`', () => {
            expect(value.description).toEqual('');
            value.description = 'Description';
            expect(value.description).toEqual('Description');
        });

        it('should have property `tokenBalanceChange`', () => {
            expect(value.tokenBalanceChange).toEqual(0);
            value.tokenBalanceChange = 1;
            expect(value.tokenBalanceChange).toEqual(1);
        });

        it('should have property `isMigrating`', () => {
            expect(value.isMigrating).toBeUndefined();
            value.isMigrating = true;
            expect(value.isMigrating).toBeTrue();
        });

        it('should have property `group`', () => {
            const mockedGroup: TokenOptionGroup = jasmine.createSpyObj(
                'TokenOptionGroup',
                [],
                ['configuration']
            ) as unknown as TokenOptionGroup;
            value.group = mockedGroup;
            expect(value.group).toEqual(mockedGroup);
        });

        it('should throw error when accessing `group` before `group` is set', () => {
            expect(() => value.group).toThrowError('Token option group is not set yet!');
        });

        // +-------------------------------------------------------+
        // | Check for existance of any other JSON properties here |
        // +-------------------------------------------------------+

        validRawValuesPair.forEach(([data, rawData]) => {
            it(`should decode successfully with raw data ${JSON.stringify(rawData)}`, () => {
                expect(value.fromRawData(rawData)).toBeSupersetOf(data);
            });
        });

        invalidRawValues.forEach((rawData) => {
            it(`should fail to decode with invalid raw data ${JSON.stringify(rawData)}`, () => {
                expect(() => value.fromRawData(rawData)).toThrowError();
            });
        });

        validValues.forEach((data) => {
            it(`should construct successfully with data ${JSON.stringify(data)}`, () => {
                expect(value.fromData(data)).toBeSupersetOf(data);
            });
        });

        invalidValues.forEach((data) => {
            it(`should fail to construct with invalid data ${JSON.stringify(data)}`, () => {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                expect(() => value.fromData(data as any)).toThrowError();
            });
        });

        validRawValuesPair.forEach(([data, rawData]) => {
            it(`should encode successfully to raw data with data ${JSON.stringify(data)}`, () => {
                const result = value.fromData(data).toJSON();
                expect(result).toEqual({
                    ...rawData,
                    description: rawData.description ?? ''
                });
            });
        });
    });
});
